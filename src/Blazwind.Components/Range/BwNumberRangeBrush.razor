@namespace Blazwind.Components.Range
@inject IJSRuntime JS
@implements IAsyncDisposable
@using System.Globalization
@using Blazwind.Components.Shared
@using Microsoft.JSInterop
@inherits BwBase

@{
    var colorName = Color.ToString().ToLower();
    var brushFillClass = $"bw-brush-fill-{colorName}";
    var handleClass = $"bw-brush-handle bw-brush-handle-{colorName}";
    var barActiveClass = $"bw-brush-bar-active-{colorName}";
    var textColorClass = $"bw-brush-text-{colorName}";
    var presetActiveClass = $"bw-brush-preset-active-{colorName}";
}

<div class="@CombineClasses("bw-number-range-brush")" style="@Style" id="@_elementId"
     @attributes="AdditionalAttributes">
    @if (!string.IsNullOrEmpty(Label))
    {
        <label class="bw-brush-label">@Label</label>
    }

    @* Mini Histogram/Bar Chart *@
    @if (ShowHistogram && Data?.Any() == true)
    {
        <div class="h-12 flex items-end gap-px mb-1 px-0.5">
            @foreach (var (value, index) in Data.Select((v, i) => (v, i)))
            {
                var height = MaxDataValue > 0 ? value / MaxDataValue * 100 : 0;
                var isInRange = IsIndexInRange(index);
                <div
                    class="flex-1 rounded-t transition-all duration-150 @(isInRange ? barActiveClass : "bg-gray-300 dark:bg-gray-600")"
                    style="height: @(Math.Max(4, height))%;"></div>
            }
        </div>
    }

    @* Brush Track *@
    <div class="bw-brush-track h-10">
        @* Inactive areas *@
        <div class="bw-brush-inactive left-0" style="width: @GetInvariantPercent(StartPercent)%;"></div>
        <div class="bw-brush-inactive right-0" style="width: @GetInvariantPercent(100 - EndPercent)%;"></div>

        @* Selection Brush *@
        <div class="bw-brush-selection @brushFillClass"
             style="left: @GetInvariantPercent(StartPercent)%; width: @GetInvariantPercent(EndPercent - StartPercent)%;">

            @* Left Handle *@
            <div class="bw-brush-handle-left @handleClass">
                <div class="w-0.5 h-5 bg-white/70 rounded-full"></div>
            </div>

            @* Grip Pattern *@
            <div class="bw-brush-grip">
                <div class="bw-brush-grip-bar" style="height: 0.75rem;"></div>
                <div class="bw-brush-grip-bar" style="height: 0.75rem;"></div>
            </div>

            @* Right Handle *@
            <div class="bw-brush-handle-right @handleClass">
                <div class="w-0.5 h-5 bg-white/70 rounded-full"></div>
            </div>
        </div>

        @* Scale Labels *@
        @if (ShowScale)
        {
            <div class="absolute -bottom-5 inset-x-0 flex justify-between text-[10px] text-gray-400">
                <span>@FormatValue(Min)</span>
                <span>@FormatValue((Min + Max) / 2)</span>
                <span>@FormatValue(Max)</span>
            </div>
        }
    </div>

    @* Value Display *@
    @if (ShowValues)
    {
        <div class="mt-6 flex items-center justify-center gap-4">
            <div class="flex items-center gap-1.5 px-3 py-1.5 rounded-lg bg-gray-50 dark:bg-gray-800">
                <span class="text-xs text-gray-500 dark:text-gray-400">Min:</span>
                <span class="text-sm font-semibold @textColorClass">@FormatValue(CurrentStart)</span>
            </div>
            <i class="fa-solid fa-arrow-right text-gray-400 text-xs"></i>
            <div class="flex items-center gap-1.5 px-3 py-1.5 rounded-lg bg-gray-50 dark:bg-gray-800">
                <span class="text-xs text-gray-500 dark:text-gray-400">Max:</span>
                <span class="text-sm font-semibold @textColorClass">@FormatValue(CurrentEnd)</span>
            </div>
        </div>
    }

    @* Presets *@
    @if (Presets?.Any() == true)
    {
        <div class="mt-3 flex flex-wrap justify-center gap-2">
            @foreach (var preset in Presets)
            {
                <button type="button"
                        class="px-2 py-1 text-xs rounded-md transition-colors
                                                       @(IsPresetActive(preset) ? presetActiveClass : "bg-gray-100 text-gray-600 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300")"
                        @onclick="() => ApplyPreset(preset)">
                    @preset.Label
                </button>
            }
        </div>
    }
</div>

@code {

    [Parameter]
    public double Min { get; set; }

    [Parameter]
    public double Max { get; set; } = 100;

    [Parameter]
    public double Step { get; set; } = 1;

    [Parameter]
    public double Start { get; set; } = 20;

    [Parameter]
    public double End { get; set; } = 80;

    [Parameter]
    public double MinWidthPercent { get; set; } = 5;

    [Parameter]
    public string? Label { get; set; }

    [Parameter]
    public string? Prefix { get; set; }

    [Parameter]
    public string? Suffix { get; set; }

    [Parameter]
    public string? Format { get; set; }

    [Parameter]
    public bool ShowValues { get; set; } = true;

    [Parameter]
    public bool ShowScale { get; set; } = true;

    [Parameter]
    public bool ShowHistogram { get; set; } = true;

    [Parameter]
    public List<double>? Data { get; set; }

    [Parameter]
    public List<NumberBrushPreset>? Presets { get; set; }

    [Parameter]
    public BwColor Color { get; set; } = BwColor.Primary;

    // Removed Class and Style parameters (inherited)
    [Parameter]
    public EventCallback<BrushChangedEventArgs<double>> OnBrushChanged { get; set; }

    private string _elementId = "";
    private DotNetObjectReference<BwNumberRangeBrush>? _dotNetRef;

    private bool _isDragging;

    private double _prevStart;
    private double _prevEnd;
    private double _prevMin; // Needed as Min/Max changes affect percent calculation
    private double _prevMax;

    private double StartPercent { get; set; }

    private double EndPercent { get; set; }

    private double CurrentStart => SnapToStep(Min + (Max - Min) * (StartPercent / 100));
    private double CurrentEnd => SnapToStep(Min + (Max - Min) * (EndPercent / 100));
    private double MaxDataValue => Data?.Max() ?? 0;

    protected override bool ShouldRender()
    {
        return !_isDragging;
    }

    protected override void OnInitialized()
    {
        _elementId = Id ?? $"bw-number-brush-{Guid.NewGuid():N}";
        InitializeState();
    }

    private void InitializeState()
    {
        StartPercent = (Start - Min) / (Max - Min) * 100;
        EndPercent = (End - Min) / (Max - Min) * 100;

        _prevStart = Start;
        _prevEnd = End;
        _prevMin = Min;
        _prevMax = Max;
    }

    protected override void OnParametersSet()
    {
        if (_isDragging) return;

        var paramsChanged = Math.Abs(Start - _prevStart) > double.Epsilon ||
                            Math.Abs(End - _prevEnd) > double.Epsilon ||
                            Math.Abs(Min - _prevMin) > double.Epsilon ||
                            Math.Abs(Max - _prevMax) > double.Epsilon;

        if (!paramsChanged) return;

        StartPercent = (Start - Min) / (Max - Min) * 100;
        EndPercent = (End - Min) / (Max - Min) * 100;

        _prevStart = Start;
        _prevEnd = End;
        _prevMin = Min;
        _prevMax = Max;
    }

    [JSInvokable]
    public void HandleDragStart()
    {
        _isDragging = true;
    }

    [JSInvokable]
    public void HandleDragEnd()
    {
        _isDragging = false;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("Blazwind.RangeBrush.initialize", _elementId, _dotNetRef, StartPercent, EndPercent,
                MinWidthPercent);
        }
    }

    [JSInvokable]
    public async Task HandleBrushChanged(double startPercent, double endPercent)
    {
        StartPercent = Math.Round(startPercent, 2);
        EndPercent = Math.Round(endPercent, 2);

        await OnBrushChanged.InvokeAsync(new BrushChangedEventArgs<double>
        {
            Start = CurrentStart,
            End = CurrentEnd,
            Min = Min,
            Max = Max,
            StartPercent = StartPercent,
            EndPercent = EndPercent
        });

        StateHasChanged();
    }

    private async Task ApplyPreset(NumberBrushPreset preset)
    {
        StartPercent = (preset.Start - Min) / (Max - Min) * 100;
        EndPercent = (preset.End - Min) / (Max - Min) * 100;

        await JS.InvokeVoidAsync("Blazwind.RangeBrush.updatePosition", _elementId, StartPercent, EndPercent);

        await OnBrushChanged.InvokeAsync(new BrushChangedEventArgs<double>
        {
            Start = preset.Start,
            End = preset.End,
            Min = Min,
            Max = Max,
            StartPercent = StartPercent,
            EndPercent = EndPercent
        });
    }

    private bool IsPresetActive(NumberBrushPreset preset)
    {
        return Math.Abs(CurrentStart - preset.Start) < Step && Math.Abs(CurrentEnd - preset.End) < Step;
    }

    private bool IsIndexInRange(int index)
    {
        if (Data == null || Data.Count == 0) return false;
        var percent = (double)index / (Data.Count - 1) * 100;
        return percent >= StartPercent && percent <= EndPercent;
    }

    private double SnapToStep(double value)
    {
        return Math.Round(value / Step) * Step;
    }

    private string FormatValue(double value)
    {
        var result = Prefix ?? "";
        result += string.IsNullOrEmpty(Format) ? value.ToString("N0") : value.ToString(Format);
        result += Suffix ?? "";
        return result;
    }

    private string GetInvariantPercent(double value)
    {
        return value.ToString("0.##", CultureInfo.InvariantCulture);
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("Blazwind.RangeBrush.dispose", _elementId);
        }
        catch
        {
        }

        _dotNetRef?.Dispose();
    }

    public class NumberBrushPreset
    {
        public string Label { get; set; } = "";
        public double Start { get; set; }
        public double End { get; set; }
    }

}