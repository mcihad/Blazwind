@namespace Blazwind.Components.Input
@using Blazwind.Components.HelpTooltip
@using Blazwind.Components.Shared
@inherits BwBaseInput<List<string>>

@{
    var hasError = !IsValid || !string.IsNullOrEmpty(ErrorMessage);
    var hasLabel = !string.IsNullOrEmpty(Label);
    var hasHelper = !string.IsNullOrEmpty(HelperText);

    var sizeClass = Size switch
    {
        BwSize.Small => "p-1.5 min-h-[32px] text-xs gap-1.5",
        BwSize.Large => "p-4 min-h-[56px] text-base gap-3",
        _ => "p-3 min-h-[42px] text-sm gap-2"
    };

    var tagSizeClass = Size switch
    {
        BwSize.Small => "px-1.5 py-0.5 text-xs",
        BwSize.Large => "px-3 py-1.5 text-sm",
        _ => "px-2.5 py-1 text-sm"
    };

    var marginClass = EffectiveDensity switch
    {
        BwFormDensity.Compact => "mb-2",
        BwFormDensity.Relaxed => "mb-6",
        _ => "mb-4"
    };

    var labelSpacingClass = EffectiveDensity switch
    {
        BwFormDensity.Compact => "mb-0.5",
        BwFormDensity.Relaxed => "mb-2",
        _ => "mb-1.5"
    };

    var borderClass = hasError
    ? "bw-input-error"
    : "border-[var(--bw-color-border)] focus-within:border-[var(--bw-color-primary)]";
}

<div class="@CombineClasses(marginClass)" style="@Style" id="@Id" @attributes="AdditionalAttributes">
    @if (hasLabel)
    {
        <div class="flex items-center gap-1 @labelSpacingClass">
            <label class="bw-label">
                @Label
                @if (IsRequired)
                {
                    <span class="bw-required">*</span>
                }
            </label>
            @if (hasHelper && EffectiveHelpTextMode == BwHelpTextMode.Popup)
            {
                <BwHelpTooltip Content="@HelperText" Size="BwSize.Small" />
            }
        </div>
    }

    <div
        class="bw-tag-input-container flex flex-wrap rounded transition-colors duration-200 outline-none @(IsDisabled ? "bw-input-disabled" : "") @borderClass @sizeClass">
        @* Tags *@
        @foreach (var tag in Tags)
        {
            var tagValue = tag;
            <span class="bw-tag inline-flex items-center gap-1 @tagSizeClass rounded">
                @tag
                @if (!IsDisabled && !IsReadOnly)
                {
                    <button type="button" class="bw-tag-remove" @onclick="() => RemoveTag(tagValue)"
                        @onclick:stopPropagation="true">
                        <i class="fa-solid fa-xmark text-xs"></i>
                    </button>
                }
            </span>
        }

        @* Input *@
        @if (!IsDisabled && !IsReadOnly && (!MaxTags.HasValue || Tags.Count < MaxTags))
        {
            <input type="text" class="bw-tag-input" placeholder="@(Tags.Count == 0 ? Placeholder : "")" @bind="_inputValue"
                @bind:event="oninput" @bind:after="HandleInputAfter" @onkeydown="HandleKeyDown" />
        }
    </div>

    <div class="flex justify-between items-center mt-1">
        @if (hasError)
        {
            <p class="bw-error-text">
                <i class="fa-solid fa-circle-exclamation"></i>
                @DisplayError
            </p>
        }
        else if (hasHelper && EffectiveHelpTextMode == BwHelpTextMode.Inline)
        {
            <p class="bw-helper-text">@HelperText</p>
        }
        else
        {
            <span></span>
        }

        @if (MaxTags.HasValue)
        {
            <span
                class="text-xs @(Tags.Count >= MaxTags ? "text-[color:var(--bw-color-danger)] font-medium" : "text-[color:var(--bw-color-text-muted)]")">
                @Tags.Count / @MaxTags
            </span>
        }
    </div>
</div>

@code {
    private string _inputValue = "";

    /// <summary>List of tags</summary>
    [Parameter]
    public List<string> Tags
    {
        get => Value ?? new List<string>();
        set => Value = value;
    }

    [Parameter]
    public EventCallback<List<string>> TagsChanged { get; set; }

    /// <summary>Maximum number of tags</summary>
    [Parameter]
    public int? MaxTags { get; set; }

    /// <summary>Allow duplicate tags</summary>
    [Parameter]
    public bool AllowDuplicates { get; set; }

    /// <summary>Keys that trigger tag addition</summary>
    [Parameter]
    public string[] TriggerKeys { get; set; } = new[] { "Enter", "Tab" };

    [Parameter]
    public EventCallback<string> OnTagAdded { get; set; }

    [Parameter]
    public EventCallback<string> OnTagRemoved { get; set; }


    #region Event Handlers

    protected override async Task HandleKeyDown(KeyboardEventArgs e)
    {
        await base.HandleKeyDown(e);

        // Handle Enter key
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(_inputValue))
        {
            await AddTag(_inputValue.Trim());
            return;
        }

        // Handle Tab key
        if (e.Key == "Tab" && !string.IsNullOrWhiteSpace(_inputValue))
        {
            await AddTag(_inputValue.Trim());
        }
        else if (e.Key == "Backspace" && string.IsNullOrEmpty(_inputValue) && Tags.Count > 0)
        {
            await RemoveTag(Tags.Last());
        }
    }

    private async Task HandleInputAfter()
    {
        // Check for comma - add tag and clear the comma
        if (_inputValue.Contains(','))
        {
            var parts = _inputValue.Split(',', StringSplitOptions.RemoveEmptyEntries);
            foreach (var part in parts)
            {
                var trimmed = part.Trim();
                if (!string.IsNullOrWhiteSpace(trimmed))
                {
                    await AddTag(trimmed);
                }
            }
            _inputValue = "";
        }
    }

    private async Task AddTag(string tag)
    {
        if (string.IsNullOrWhiteSpace(tag)) return;
        if (!AllowDuplicates && Tags.Contains(tag)) return;
        if (MaxTags.HasValue && Tags.Count >= MaxTags) return;

        Tags.Add(tag);
        _inputValue = "";

        await TagsChanged.InvokeAsync(Tags);
        await ValueChanged.InvokeAsync(Tags);
        await OnTagAdded.InvokeAsync(tag);
        await OnChange.InvokeAsync(Tags);

        if (CascadedEditContext != null && For != null)
        {
            CascadedEditContext.NotifyFieldChanged(FieldIdentifier);
        }
    }

    private async Task RemoveTag(string tag)
    {
        if (Tags.Remove(tag))
        {
            await TagsChanged.InvokeAsync(Tags);
            await ValueChanged.InvokeAsync(Tags);
            await OnTagRemoved.InvokeAsync(tag);
            await OnChange.InvokeAsync(Tags);
        }
    }

    #endregion


}