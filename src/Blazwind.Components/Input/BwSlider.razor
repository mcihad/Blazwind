@namespace Blazwind.Components.Input
@using System.Globalization
@using Blazwind.Components.HelpTooltip
@using Blazwind.Components.Shared
@inherits BwBaseInput<double>

@{
    var marginClass = GetDensityMarginClass();
    var percentage = (Value - Min) / (Max - Min) * 100;

    var fillColor = Color switch
    {
        BwColor.Primary => "var(--bw-color-primary)",
        BwColor.Success => "var(--bw-color-success)",
        BwColor.Danger => "var(--bw-color-danger)",
        BwColor.Warning => "var(--bw-color-warning)",
        BwColor.Info => "var(--bw-color-info)",
        _ => "var(--bw-color-primary)"
    };

    var thumbColor = Color switch
    {
        BwColor.Primary => "var(--bw-color-primary)",
        BwColor.Success => "var(--bw-color-success)",
        BwColor.Danger => "var(--bw-color-danger)",
        BwColor.Warning => "var(--bw-color-warning)",
        BwColor.Info => "var(--bw-color-info)",
        _ => "var(--bw-color-primary)"
    };

    var heightPx = Size switch
    {
        BwSize.Small => "4px",
        BwSize.Large => "12px",
        _ => "8px"
    };

    var thumbSizePx = Size switch
    {
        BwSize.Small => "12px",
        BwSize.Large => "24px",
        _ => "16px"
    };

    // For vertical sliders, we rotate the horizontal slider by -90deg.
    // So the visual "width" is the "height" property, and visual "height" is "width".
    // The gradient direction is always "to right" relative to the element, which becomes "to top" visually after rotation.

    var percentageStr = percentage.ToString("0.##", CultureInfo.InvariantCulture);
    var trackBgColor = "var(--bw-gray-200)";
    var trackGradient = $"linear-gradient(to right, {fillColor} 0%, {fillColor} {percentageStr}%, {trackBgColor} {percentageStr}%, {trackBgColor} 100%)";
    var errorTrackColor = HasError ? "var(--bw-color-danger-soft)" : trackBgColor;

    // Layout Logic:
    // Vertical: Use flex-col to stack Label -> Slider -> Value (centered).
    // Horizontal: Use block (standard).
    var outerClass = IsVertical ? $"inline-flex flex-col items-center gap-2 {marginClass} {Class}" : $"{marginClass} {Class}";

    // Label Row:
    // Vertical: Simple centered label.
    // Horizontal: Flex row with justify-between (Label Left, Value Right).
    var labelRowClass = IsVertical ? "text-center mb-1" : "flex justify-between items-center mb-2";

    // Slider Container:
    // Vertical: Fixed WxH wrapper to reserve space. Input is absolute centered inside.
    // Horizontal: Relative wrapper.
    var sliderContainerClass = IsVertical ? "relative flex-none" : "relative w-full"; // flex-none important for vertical
    var sliderContainerStyle = IsVertical ? $"width: {thumbSizePx}; height: {VerticalHeight};" : "";

    var sliderClass = "bw-slider";

    // Input Style:
    // Vertical: Absolute, Centered, Rotated. Width = Visual Height.
    var sliderStyle = IsVertical
        ? $"--slider-track-height: {heightPx}; --slider-thumb-size: {thumbSizePx}; --slider-fill-color: {fillColor}; --slider-thumb-color: {thumbColor}; background: {trackGradient}; width: {VerticalHeight}; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-90deg);"
        : $"--slider-track-height: {heightPx}; --slider-thumb-size: {thumbSizePx}; --slider-fill-color: {fillColor}; --slider-thumb-color: {thumbColor}; background: {trackGradient}; width: 100%;";
}

<div class="@CombineClasses(outerClass)" style="@Style" id="@Id">
    @if (HasLabel || (ShowValue && !IsVertical))
    {
        <div class="@labelRowClass">
            @if (HasLabel)
            {
                <div class="flex items-center gap-1 @(IsVertical ? "justify-center" : "")">
                    <label class="bw-label whitespace-nowrap">
                        @Label
                        @if (IsRequired)
                        {
                            <span class="bw-required">*</span>
                        }
                    </label>
                    @if (HasHelper && EffectiveHelpTextMode == BwHelpTextMode.Popup)
                    {
                        <BwHelpTooltip Content="@HelperText" Size="BwSize.Small"/>
                    }
                </div>
            }
            @if (ShowValue && !IsVertical)
            {
                <span class="bw-label">@Value.ToString(ValueFormat)</span>
            }
        </div>
    }

    <div class="@(IsDisabled ? "opacity-50 cursor-not-allowed" : "") @sliderContainerClass"
         style="@sliderContainerStyle">
        <input type="range" class="@sliderClass" min="@Min" max="@Max" step="@Step" value="@Value"
               disabled="@IsDisabled" @oninput="HandleSliderInput" @onfocus="HandleFocusEvent" @onblur="HandleBlurEvent"
               style="@sliderStyle" @attributes="AdditionalAttributes"/>

        @* Marks for Vertical could go here, absolutely positioned if implemented *@
    </div>

    @* Vertical Value Display (Bottom) *@
    @if (ShowValue && IsVertical)
    {
        <span class="bw-label mt-1">@Value.ToString(ValueFormat)</span>
    }

    @* Horizontal Marks *@
    @if (ShowMarks && Marks != null && !IsVertical)
    {
        <div class="relative mt-1">
            @foreach (var mark in Marks)
            {
                var markPercent = (mark - Min) / (Max - Min) * 100;
                <div class="absolute -translate-x-1/2 text-xs text-[var(--bw-color-text-muted)]"
                     style="left: @markPercent%;">
                    @mark
                </div>
            }
        </div>
    }

    @* Error/Helper Messages *@
    @if (HasError)
    {
        <p class="bw-error-text @(IsVertical ? "justify-center" : "")">
            <i class="fa-solid fa-circle-exclamation"></i>
            @DisplayError
        </p>
    }
    else if (HasHelper && EffectiveHelpTextMode == BwHelpTextMode.Inline)
    {
        <p class="bw-helper-text @(IsVertical ? "text-center" : "")">@HelperText</p>
    }
</div>

@code {

    /// <summary>Minimum value</summary>
    [Parameter]
    public double Min { get; set; }

    /// <summary>Maximum value</summary>
    [Parameter]
    public double Max { get; set; } = 100;

    /// <summary>Step increment</summary>
    [Parameter]
    public double Step { get; set; } = 1;

    /// <summary>Show current value</summary>
    [Parameter]
    public bool ShowValue { get; set; } = true;

    /// <summary>Show tooltip while dragging</summary>
    [Parameter]
    public bool ShowTooltip { get; set; } = true;

    /// <summary>Show tick marks</summary>
    [Parameter]
    public bool ShowMarks { get; set; } // Renamed to simple bool to match usage in logic above

    /// <summary>Custom mark values</summary>
    [Parameter]
    public double[]? Marks { get; set; }

    /// <summary>Value format string</summary>
    [Parameter]
    public string ValueFormat { get; set; } = "0";

    /// <summary>Color variant</summary>
    [Parameter]
    public BwColor Color { get; set; } = BwColor.Primary;

    /// <summary>Vertical orientation</summary>
    [Parameter]
    public bool IsVertical { get; set; }

    /// <summary>Height for vertical slider</summary>
    [Parameter]
    public string VerticalHeight { get; set; } = "200px";

    private async Task HandleSliderInput(ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var newValue))
        {
            Value = newValue;
            await ValueChanged.InvokeAsync(Value);
            await OnChange.InvokeAsync(Value);

            if (CascadedEditContext != null && For != null)
            {
                CascadedEditContext.NotifyFieldChanged(FieldIdentifier);
            }
        }
    }

    private async Task HandleFocusEvent(FocusEventArgs e)
    {
        IsFocused = true;
        await HandleFocus(e);
    }

    private async Task HandleBlurEvent(FocusEventArgs e)
    {
        IsFocused = false;
        await HandleBlur(e);
    }

}