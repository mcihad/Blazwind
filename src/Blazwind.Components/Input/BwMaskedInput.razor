@namespace Blazwind.Components.Input
@using Blazwind.Components.HelpTooltip
@using Blazwind.Components.Shared
@using Microsoft.JSInterop
@inherits BwBaseInput<string>
@implements IAsyncDisposable
@inject IJSRuntime JS

@{
    var sizeClass = Size switch
    {
        BwSize.Small => "bw-input-small tracking-wider",
        BwSize.Large => "bw-input-large tracking-widest",
        _ => "bw-input-medium tracking-wide"
    };

    var baseClass = "bw-input font-mono";
    var stateClass = GetStateClass();
    var disabledClass = GetDisabledClass();
    var marginClass = GetDensityMarginClass();
    var labelSpacingClass = GetLabelSpacingClass();
}

<div class="@CombineClasses(marginClass)" style="@Style" id="@Id">
    @switch (EffectiveLabelPosition)
    {
        case BwLabelPosition.Top:
            @if (HasLabel)
            {
                <div class="flex items-center gap-1 @labelSpacingClass">
                    <label class="bw-label">
                        @Label
                        @if (IsRequired)
                        {
                            <span class="bw-required">*</span>
                        }
                    </label>
                    @if (HasHelper && EffectiveHelpTextMode == BwHelpTextMode.Popup)
                    {
                        <BwHelpTooltip Content="@HelperText" Size="BwSize.Small" />
                    }
                </div>
            }

            <div class="relative">
                <input @ref="_inputRef" type="text" id="@_inputId" class="@baseClass @sizeClass @stateClass @disabledClass"
                    placeholder="@GetPlaceholder()" disabled="@IsDisabled" readonly="@IsReadOnly" @onfocus="HandleFocusEvent"
                    @onblur="HandleBlurEvent" @attributes="AdditionalAttributes" />
            </div>
            break;

        case BwLabelPosition.Left:
            <div class="flex items-start gap-3">
                @if (HasLabel)
                {
                    <div class="flex items-center gap-1 pt-2.5 shrink-0" style="width: @LabelWidth; min-width: @LabelWidth;">
                        <label class="bw-label text-right flex-1">
                            @Label
                            @if (IsRequired)
                            {
                                <span class="bw-required">*</span>
                            }
                        </label>
                        @if (HasHelper && EffectiveHelpTextMode == BwHelpTextMode.Popup)
                        {
                            <BwHelpTooltip Content="@HelperText" Size="BwSize.Small" />
                        }
                    </div>
                }
                <div class="flex-1 relative">
                    <input @ref="_inputRef" type="text" id="@_inputId" class="@baseClass @sizeClass @stateClass @disabledClass"
                        placeholder="@GetPlaceholder()" disabled="@IsDisabled" readonly="@IsReadOnly"
                        @onfocus="HandleFocusEvent" @onblur="HandleBlurEvent" @attributes="AdditionalAttributes" />
                </div>
            </div>
            break;

        default:
            <div class="relative">
                <input @ref="_inputRef" type="text" id="@_inputId" class="@baseClass @sizeClass @stateClass @disabledClass"
                    placeholder="@GetPlaceholder()" disabled="@IsDisabled" readonly="@IsReadOnly" @onfocus="HandleFocusEvent"
                    @onblur="HandleBlurEvent" @attributes="AdditionalAttributes" />
            </div>
            break;
    }

    @* Error/Helper Messages *@
    @if (HasError)
    {
        <p class="bw-error-text">
            <i class="fa-solid fa-circle-exclamation"></i>
            @DisplayError
        </p>
    }
    else if (HasHelper && EffectiveHelpTextMode == BwHelpTextMode.Inline)
    {
        <p class="bw-helper-text">@HelperText</p>
    }
</div>

@code {

    /// <summary>Mask pattern. Use # for digits, A for letters, * for any character.</summary>
    [Parameter]
    public string Mask { get; set; } = "";

    /// <summary>Character shown for unfilled positions</summary>
    [Parameter]
    public char MaskChar { get; set; } = '_';

    /// <summary>Preset mask type</summary>
    [Parameter]
    public BwMaskPreset? Preset { get; set; }

    /// <summary>If true (default), Value returns raw characters only. If false, Value includes mask literals.</summary>
    [Parameter]
    public bool UnmaskValue { get; set; } = true;

    /// <summary>Override UnmaskValue per preset. Phone/CreditCard return raw, Date/Time return formatted.</summary>
    [Parameter]
    public bool? ForceUnmask { get; set; }

    /// <summary>Triggered when Enter key is pressed</summary>
    [Parameter]
    public EventCallback OnEnter { get; set; }

    private ElementReference _inputRef;
    private string _inputId = $"bw-masked-{Guid.NewGuid():N}";
    private DotNetObjectReference<BwMaskedInput>? _dotNetRef;
    private bool _isInitialized;
    private string _activeMask = "";
    private bool _effectiveUnmask;
    private string? _previousValue;

    protected override void OnParametersSet()
    {
        _activeMask = Preset.HasValue ? GetPresetMask(Preset.Value) : Mask;

        // Determine effective unmask setting
        if (ForceUnmask.HasValue)
        {
            _effectiveUnmask = ForceUnmask.Value;
        }
        else if (Preset.HasValue)
        {
            // Date and Time should return formatted by default
            _effectiveUnmask = Preset.Value switch
            {
                BwMaskPreset.Date => false,
                BwMaskPreset.Time => false,
                _ => true // Phone, CreditCard, IBAN return raw
            };
        }
        else
        {
            _effectiveUnmask = UnmaskValue;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await InitializeMaskedInput();
            _isInitialized = true;
        }
        else if (_isInitialized && Value != _previousValue)
        {
            // Value changed from outside, update the input
            await SetValueFromDotNet(Value ?? "");
        }
        _previousValue = Value;
    }

    private async Task InitializeMaskedInput()
    {
        var presetName = Preset?.ToString().ToLowerInvariant() ?? "";

        // Map C# preset names to TypeScript preset names
        var tsPreset = Preset switch
        {
            BwMaskPreset.Phone => "phone",
            BwMaskPreset.CreditCard => "creditcard",
            BwMaskPreset.Date => "date",
            BwMaskPreset.Time => "time",
            BwMaskPreset.Iban => "iban-tr",
            _ => ""
        };

        var options = new
        {
            mask = string.IsNullOrEmpty(tsPreset) ? _activeMask : "",
            preset = tsPreset,
            placeholder = MaskChar.ToString(),
            returnMasked = !_effectiveUnmask
        };

        await JS.InvokeVoidAsync("Blazwind.MaskedInput.initialize", _inputId, _dotNetRef, options);

        // Set initial value if exists
        if (!string.IsNullOrEmpty(Value))
        {
            await SetValueFromDotNet(Value);
        }
    }

    private async Task SetValueFromDotNet(string value)
    {
        try
        {
            await JS.InvokeVoidAsync("Blazwind.MaskedInput.setValue", _inputId, value);
        }
        catch
        {
            // Ignore if not initialized
        }
    }

    private string GetPresetMask(BwMaskPreset preset)
    {
        return preset switch
        {
            BwMaskPreset.Phone => "(###) ### ## ##",
            BwMaskPreset.CreditCard => "#### #### #### ####",
            BwMaskPreset.Date => "##/##/####",
            BwMaskPreset.Time => "##:##",
            BwMaskPreset.Iban => "TR## #### #### #### #### #### ##",
            _ => Mask
        };
    }

    private string GetPlaceholder()
    {
        if (!string.IsNullOrEmpty(Placeholder)) return Placeholder;
        if (string.IsNullOrEmpty(_activeMask)) return "";
        return _activeMask.Replace('#', MaskChar).Replace('A', MaskChar).Replace('*', MaskChar);
    }

    /// <summary>Called from TypeScript when value changes</summary>
    [JSInvokable]
    public async Task OnValueChanged(string formattedValue, string rawValue)
    {
        var newValue = _effectiveUnmask ? rawValue : formattedValue;

        if (Value != newValue)
        {
            Value = newValue;
            _previousValue = newValue;
            await ValueChanged.InvokeAsync(Value);
            await OnChange.InvokeAsync(Value);

            if (CascadedEditContext != null && For != null)
            {
                CascadedEditContext.NotifyFieldChanged(FieldIdentifier);
            }
        }
    }

    /// <summary>Called from TypeScript when Enter key is pressed</summary>
    [JSInvokable]
    public async Task OnEnterPressed()
    {
        if (OnEnter.HasDelegate)
        {
            await OnEnter.InvokeAsync();
        }
    }

    private async Task HandleFocusEvent(FocusEventArgs e)
    {
        IsFocused = true;
        await HandleFocus(e);
    }

    private async Task HandleBlurEvent(FocusEventArgs e)
    {
        IsFocused = false;
        await HandleBlur(e);
    }

    public async ValueTask DisposeAsync()
    {
        if (_isInitialized)
        {
            try
            {
                await JS.InvokeVoidAsync("Blazwind.MaskedInput.destroy", _inputId);
            }
            catch
            {
                // Ignore disposal errors
            }
        }
        _dotNetRef?.Dispose();
    }
}