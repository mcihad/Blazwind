@namespace Blazwind.Components.CommandPalette
@inherits BwBase
@inject CommandPaletteService CommandService
@inject IJSRuntime JS
@using Microsoft.JSInterop
@implements IAsyncDisposable

@if (_isVisible)
{
    <div class="bw-cp-overlay animate-in fade-in duration-150" @onclick="Close" id="@Id"
         @attributes="AdditionalAttributes">
        <div class="bw-cp-modal animate-in zoom-in-95 fade-in duration-200" @onclick:stopPropagation="true">
            <div class="bw-cp-header">
                <i class="fa-solid fa-search bw-cp-icon"></i>
                <input type="text"
                       id="@_inputId"
                       class="bw-cp-input"
                       placeholder="@Placeholder"
                       @bind="_searchQuery"
                       @bind:event="oninput"
                       @bind:after="OnSearchChanged"
                       @onkeydown="HandleKeyDown"
                       @onkeydown:preventDefault="_preventKeyDefault"/>
                <kbd class="bw-cp-esc-badge">ESC</kbd>
            </div>

            <div class="bw-cp-results" id="@_resultsId">
                @if (_filteredCommands.Any())
                {
                    @foreach (var group in _groupedCommands)
                    {
                        <div class="bw-cp-group">
                            <div class="bw-cp-group-title">@group.Key</div>
                            @foreach (var command in group.Value)
                            {
                                var index = _filteredCommands.IndexOf(command);
                                var activeClass = index == _activeIndex ? "bw-cp-item-active" : "";

                                <button type="button"
                                        class="bw-cp-item @activeClass"
                                        @onclick="() => ExecuteCommand(command)">
                                    @if (!string.IsNullOrEmpty(command.Icon))
                                    {
                                        <i class="@command.Icon bw-cp-item-icon"></i>
                                    }
                                    <div class="flex-1 flex flex-col gap-0.5 min-w-0">
                                        <span class="bw-cp-item-title">@command.Label</span>
                                        @if (!string.IsNullOrEmpty(command.Description))
                                        {
                                            <span class="bw-cp-item-desc">@command.Description</span>
                                        }
                                    </div>
                                    @if (!string.IsNullOrEmpty(command.Shortcut))
                                    {
                                        <kbd class="bw-cp-shortcut">@command.Shortcut</kbd>
                                    }
                                </button>
                            }
                        </div>
                    }
                }
                else
                {
                    <div class="bw-cp-empty">
                        <i class="fa-solid fa-search text-3xl mb-2"></i>
                        <p class="m-0 text-sm">No results found</p>
                    </div>
                }
            </div>

            <div class="bw-cp-footer">
                <span><kbd class="bw-cp-footer-key">↑↓</kbd> Navigate</span>
                <span><kbd class="bw-cp-footer-key">↵</kbd> Select</span>
                <span><kbd class="bw-cp-footer-key">ESC</kbd> Close</span>
            </div>
        </div>
    </div>
}

@code {

    [Parameter]
    public string Placeholder { get; set; } = "Search command...";

    private DotNetObjectReference<BwCommandPalette>? _dotNetRef;
    private readonly string _inputId = $"cmd-input-{Guid.NewGuid():N}";
    private readonly string _resultsId = $"cmd-results-{Guid.NewGuid():N}";
    private string _searchQuery = "";
    private int _activeIndex;
    private bool _isVisible;
    private bool _isInitialized;

    private List<CommandItem> _filteredCommands = new();
    private Dictionary<string, List<CommandItem>> _groupedCommands = new();
    private readonly bool _preventKeyDefault = false;

    protected override void OnInitialized()
    {
        CommandService.OnVisibilityChanged += HandleVisibilityChanged;
        CommandService.OnCommandsChanged += RefreshCommands;

        _dotNetRef = DotNetObjectReference.Create(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _isInitialized = true;
            try
            {
                await JS.InvokeVoidAsync("Blazwind.commandPalette.registerKeyboardShortcut", _dotNetRef);
            }
            catch (JSException)
            {
                // JS might not be ready
            }
        }

        if (_isVisible && _isInitialized)
        {
            try
            {
                await JS.InvokeVoidAsync("Blazwind.commandPalette.focusInput", _inputId);
            }
            catch (JSException)
            {
                // JS might not be ready
            }
        }
    }

    private void HandleVisibilityChanged()
    {
        _isVisible = CommandService.IsVisible;
        if (_isVisible)
        {
            _searchQuery = "";
            _activeIndex = 0;
            RefreshCommands();
        }

        InvokeAsync(StateHasChanged);
    }

    private void HandleInput(ChangeEventArgs e)
    {
        _searchQuery = e.Value?.ToString() ?? "";
        UpdateFilteredCommands();
    }

    private void OnSearchChanged()
    {
        UpdateFilteredCommands();
    }

    private void UpdateFilteredCommands()
    {
        _groupedCommands = CommandService.GetGroupedCommands(_searchQuery);
        _filteredCommands = _groupedCommands.Values.SelectMany(x => x).ToList();
        _activeIndex = Math.Min(_activeIndex, Math.Max(0, _filteredCommands.Count - 1));
    }

    private void RefreshCommands()
    {
        UpdateFilteredCommands();
        InvokeAsync(StateHasChanged);
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "ArrowDown":
                _activeIndex = (_activeIndex + 1) % Math.Max(1, _filteredCommands.Count);
                break;
            case "ArrowUp":
                _activeIndex = (_activeIndex - 1 + _filteredCommands.Count) % Math.Max(1, _filteredCommands.Count);
                break;
            case "Enter":
                if (_filteredCommands.Count > _activeIndex && _activeIndex >= 0)
                {
                    _ = ExecuteCommand(_filteredCommands[_activeIndex]);
                }

                break;
            case "Escape":
                Close();
                break;
            default:
                _activeIndex = 0;
                RefreshCommands();
                break;
        }
    }

    private async Task ExecuteCommand(CommandItem command)
    {
        await CommandService.ExecuteCommand(command);
    }

    private void Close()
    {
        CommandService.Hide();
    }

    [JSInvokable]
    public void OnShortcutPressed()
    {
        CommandService.Toggle();
    }

    [JSInvokable]
    public void OnEscapePressed()
    {
        if (_isVisible)
        {
            CommandService.Hide();
        }
    }

    [JSInvokable]
    public void SetActiveIndex(int index)
    {
        _activeIndex = index;
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        CommandService.OnVisibilityChanged -= HandleVisibilityChanged;
        CommandService.OnCommandsChanged -= RefreshCommands;

        try
        {
            await JS.InvokeVoidAsync("Blazwind.commandPalette.unregisterKeyboardShortcut");
        }
        catch
        {
            // Ignore disposal errors
        }

        _dotNetRef?.Dispose();
    }

}
