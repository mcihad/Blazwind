@namespace Blazwind.Components.Tooltip
@using Blazwind.Components.Shared
@inherits BwBase

@{
    var placementClasses = Placement switch
    {
        BwPlacement.Top => "bottom-full left-1/2 -translate-x-1/2 mb-2",
        BwPlacement.TopStart => "bottom-full left-0 mb-2",
        BwPlacement.TopEnd => "bottom-full right-0 mb-2",
        BwPlacement.Left => "right-full top-1/2 -translate-y-1/2 mr-2",
        BwPlacement.LeftStart => "right-full top-0 mr-2",
        BwPlacement.LeftEnd => "right-full bottom-0 mr-2",
        BwPlacement.Right => "left-full top-1/2 -translate-y-1/2 ml-2",
        BwPlacement.RightStart => "left-full top-0 ml-2",
        BwPlacement.RightEnd => "left-full bottom-0 ml-2",
        BwPlacement.BottomStart => "top-full left-0 mt-2",
        BwPlacement.BottomEnd => "top-full right-0 mt-2",
        _ => "top-full left-1/2 -translate-x-1/2 mt-2" // Bottom (default)
    };

    var arrowClasses = Placement switch
    {
        BwPlacement.Top or BwPlacement.TopStart or BwPlacement.TopEnd =>
            "bottom-[-4px] left-1/2 -translate-x-1/2 rotate-45",
        BwPlacement.Left or BwPlacement.LeftStart or BwPlacement.LeftEnd =>
            "right-[-4px] top-1/2 -translate-y-1/2 rotate-45",
        BwPlacement.Right or BwPlacement.RightStart or BwPlacement.RightEnd =>
            "left-[-4px] top-1/2 -translate-y-1/2 rotate-45",
        _ => "top-[-4px] left-1/2 -translate-x-1/2 rotate-45" // Bottom
    };

    // Using string matching with CSS
    // The placement affects positioning (layout), which is fine to keep as Tailwind utilities if they are purely layout.
    // However, user wants "Theme Support". Colors are the main thing.

    var colorClass = Color.ToString().ToLower();
    if (Color == BwColor.Dark) colorClass = "default"; // Mapping 'Dark' (default enum) to 'default' class or 'dark' class
    else if (Color == BwColor.Light) colorClass = "light";
}

<div class="bw-tooltip-trigger" style="@Style" id="@Id" @attributes="AdditionalAttributes"
     @onmouseenter="HandleMouseEnter" @onmouseleave="HandleMouseLeave"
     @onfocus="HandleFocus" @onblur="HandleBlur">
    <div class="inline-block">
        @ChildContent
    </div>

    @if (_isVisible && !string.IsNullOrEmpty(Text))
    {
        <div role="tooltip" class="bw-tooltip @(_isVisible ? "show" : "") @colorClass @placementClasses @SizeClasses">
            @if (ShowArrow)
            {
                <div class="bw-tooltip-arrow @arrowClasses"></div>
            }
            @if (!string.IsNullOrEmpty(Icon))
            {
                <i class="@Icon mr-1.5"></i>
            }
            @Text
        </div>
    }
</div>

@code {

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public string? Text { get; set; }

    [Parameter]
    public string? Icon { get; set; }

    [Parameter]
    public BwPlacement Placement { get; set; } = BwPlacement.Top;

    [Parameter]
    public BwColor Color { get; set; } = BwColor.Dark;

    [Parameter]
    public BwSize Size { get; set; } = BwSize.Medium;

    [Parameter]
    public bool ShowArrow { get; set; } = true;

    [Parameter]
    public bool Disabled { get; set; }

    [Parameter]
    public int ShowDelay { get; set; } = 100;

    [Parameter]
    public int HideDelay { get; set; }

    [Parameter]
    public TooltipTrigger Trigger { get; set; } = TooltipTrigger.Hover;
    // Removed Class parameter (inherited)

    private bool _isVisible;
    private CancellationTokenSource? _showCts;
    private CancellationTokenSource? _hideCts;

    private string SizeClasses => Size.ToString().ToLower();

    private async Task HandleMouseEnter()
    {
        if (Disabled || Trigger == TooltipTrigger.Focus) return;

        _hideCts?.Cancel();
        _showCts = new CancellationTokenSource();

        try
        {
            await Task.Delay(ShowDelay, _showCts.Token);
            _isVisible = true;
            StateHasChanged();
        }
        catch (TaskCanceledException)
        {
        }
    }

    private async Task HandleMouseLeave()
    {
        if (Trigger == TooltipTrigger.Focus) return;

        _showCts?.Cancel();
        _hideCts = new CancellationTokenSource();

        try
        {
            await Task.Delay(HideDelay, _hideCts.Token);
            _isVisible = false;
            StateHasChanged();
        }
        catch (TaskCanceledException)
        {
        }
    }

    private void HandleFocus()
    {
        if (Disabled || Trigger == TooltipTrigger.Hover) return;
        _isVisible = true;
    }

    private void HandleBlur()
    {
        if (Trigger == TooltipTrigger.Hover) return;
        _isVisible = false;
    }

    public void Show()
    {
        _isVisible = true;
        StateHasChanged();
    }

    public void Hide()
    {
        _isVisible = false;
        StateHasChanged();
    }

    public enum TooltipTrigger
    {
        Hover,
        Focus,
        Both
    }

}