@namespace Blazwind.Components.OtpInput
@using Blazwind.Components.Shared
@using Microsoft.JSInterop
@inherits BwBase
@inject IJSRuntime JS

@{
    var sizeClass = Size.ToString().ToLower();
    var variantClass = Variant.ToString().ToLower();
    var colorClass = $"color-{Color.ToString().ToLower()}";

    var inputClass = CombineClasses("bw-otp-input", sizeClass, variantClass, colorClass, HasError ? "error" : "");
    var groupClass = CombineClasses("bw-otp-group", sizeClass);
}

<div class="@CombineClasses("bw-otp-container")" style="@Style" id="@Id" @attributes="AdditionalAttributes">
    @if (!string.IsNullOrEmpty(Label))
    {
        <label class="bw-otp-label">@Label</label>
    }

    <div class="@groupClass">
        @for (var i = 0; i < Length; i++)
        {
            var index = i;
            <input type="@(IsMasked ? "password" : "text")" maxlength="1"
                   inputmode="@(NumericOnly ? "numeric" : "text")"
                   pattern="@(NumericOnly ? "[0-9]" : null)" class="@inputClass"
                   value="@GetCharAt(index)" disabled="@IsDisabled" @oninput="e => HandleInput(index, e)"
                   @onkeydown="e => HandleKeyDown(index, e)" @onfocus="() => HandleFocus(index)"
                   @ref="_inputRefs[index]"/>
        }
    </div>

    @if (HasError && !string.IsNullOrEmpty(ErrorMessage))
    {
        <span class="bw-otp-error-message">@ErrorMessage</span>
    }

    @if (!string.IsNullOrEmpty(HelperText) && !HasError)
    {
        <span class="bw-otp-helper-text">@HelperText</span>
    }
</div>

@code {

    [Parameter]
    public int Length { get; set; } = 6;

    [Parameter]
    public string Value { get; set; } = "";

    [Parameter]
    public bool NumericOnly { get; set; } = true;

    [Parameter]
    public bool IsMasked { get; set; }

    [Parameter]
    public bool IsDisabled { get; set; }

    [Parameter]
    public bool AutoFocus { get; set; }

    [Parameter]
    public bool HasError { get; set; }

    [Parameter]
    public string? Label { get; set; }

    [Parameter]
    public string? ErrorMessage { get; set; }

    [Parameter]
    public string? HelperText { get; set; }

    [Parameter]
    public BwSize Size { get; set; } = BwSize.Medium;

    [Parameter]
    public BwColor Color { get; set; } = BwColor.Primary;

    [Parameter]
    public BwVariant Variant { get; set; } = BwVariant.Outline;

    [Parameter]
    public EventCallback<string> ValueChanged { get; set; }

    [Parameter]
    public EventCallback<string> OnComplete { get; set; }

    private ElementReference[] _inputRefs = new ElementReference[10];
    private string _internalValue = "";

    protected override void OnInitialized()
    {
        _internalValue = Value.PadRight(Length).Substring(0, Length);
        _inputRefs = new ElementReference[Length];
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && AutoFocus)
        {
            await FocusInput(0);
        }
    }

    private string GetCharAt(int index)
    {
        if (index < _internalValue.Length)
        {
            var c = _internalValue[index];
            return c == ' ' ? "" : c.ToString();
        }

        return "";
    }

    private async Task HandleInput(int index, ChangeEventArgs e)
    {
        var inputValue = e.Value?.ToString() ?? "";

        if (NumericOnly && !string.IsNullOrEmpty(inputValue) && !char.IsDigit(inputValue[0]))
        {
            return;
        }

        var chars = _internalValue.ToCharArray();
        chars[index] = string.IsNullOrEmpty(inputValue) ? ' ' : inputValue[0];
        _internalValue = new string(chars);

        await UpdateValue();

        if (!string.IsNullOrEmpty(inputValue) && index < Length - 1)
        {
            await FocusInput(index + 1);
        }

        if (!_internalValue.Contains(' ') && _internalValue.Trim().Length == Length)
        {
            await OnComplete.InvokeAsync(_internalValue.Trim());
        }
    }

    private async Task HandleKeyDown(int index, KeyboardEventArgs e)
    {
        if (e.Key == "Backspace" && index > 0 && string.IsNullOrEmpty(GetCharAt(index)))
        {
            await FocusInput(index - 1);
        }
        else if (e.Key == "ArrowLeft" && index > 0)
        {
            await FocusInput(index - 1);
        }
        else if (e.Key == "ArrowRight" && index < Length - 1)
        {
            await FocusInput(index + 1);
        }
    }

    private void HandleFocus(int index)
    {
        // Handle focus
    }

    private async Task FocusInput(int index)
    {
        if (index >= 0 && index < _inputRefs.Length)
        {
            try
            {
                await _inputRefs[index].FocusAsync();
            }
            catch
            {
            }
        }
    }

    private async Task UpdateValue()
    {
        var trimmed = _internalValue.Replace(" ", "");
        await ValueChanged.InvokeAsync(trimmed);
    }

    public void Clear()
    {
        _internalValue = new string(' ', Length);
        StateHasChanged();
    }

}